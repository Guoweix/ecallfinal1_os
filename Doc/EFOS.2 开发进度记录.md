## 开发进度记录
本文档记录了开发过程中阶段性进展。
- 4月7日之前
由于去年参加过CCSC2023，但是核心成员未能继续比赛于是在去年实现中断的半成品系统上继续开发。
继承去年核心的字符串操作库以及输出调试工具Kout。基本实现中断，物理内存链式管理功能。
- 4月15日
基本确定内核分工，协作方式，操作系统基础知识培训。更简洁的makefile的编写。
- 4月19日
由于去年比赛的virtio驱动存在严重缺陷，于是今年提前查找virtio资料，虽然此时还没有实现进程管理部分，但是认为可以先通过轮询的方式实现驱动部分。理清virtio的原理后，实现了vring的交互，但是未能达到预期效果，遂暂时搁置。
- 4月20日
在物理内存上新增小物理内存的分配和管理，将内存块分为三级进行管理，实现了kmalloc和kfree的功能，使之能够动态的根据需要的大小使用不同的内存管理器。
- 4月23日
由于没有经验，没有先实现进程，而是先去实现了信号量，导致像无头苍蝇一样没搞清楚信号量发生作用的原理。此时的信号量并无实际作用，只有自旋锁部分有真正的效果。代码也只实现了队列的部分，不能对进程状态进行管理。于是信号量部分也搁置。
- 4月25日
开始写进程的部分了，设计进程PCB,但是此时全部的内存都已经被映射到虚拟内存部分，但是未能实现VMS的管理，考虑到shedule需要进行虚拟进程的切换于是只实现了进程结构体的部分操作定义，核心的start，run,等功能还没有理清。
- 4月27日
实现虚拟内存部分，使用sv39完成虚拟页的映射和管理。实现了虚拟内存的缺页处理，尤其是VMS的实现和管理，让进程切换得以继续。
- 4月28日
实现init进程，代替原来的boot。初步设计了进程的生命周期，实现基本的接口。
- 5月2日
实现从内核函数中创建进程，但是在进程调度时出现内存错误。在反复勘误和重新设计调度逻辑之后，设计了新的start函数用于启动进程，同时shedule也决定采用简单的时间片轮转+RR调度算法。砍掉了不擅长使用的汇编，将原本功能复杂的start函数尽可能的化简，对于原来多出的函数选择创建新的进程而不是延长现有进程的内核时间。
- 5月13日
由于没有文件系统，于是先使用inirt的方式将，用户elf映射到内存当中，启动用户进程让前期代码考虑不周全的地方全部爆发了，所以导致了非常多的问题。
首先在创建用户镜像时就导致了链接的问题，不过最早因为gcc工具的默认值使之神奇的运作起来了。后面在实现用户进程的退出时才排查出问题。
然后是用户程序的入口点导致问题，之前的start函数在进入用户进程希望运行一段函数帮助实现载入镜像等功能，但是这段程序是由汇编执行的，在执行过后不知道怎么切换内存的权限导致访存因为权限失败。导致花了很长时间去修复相关问题。由于进程部分的彻底重构，我们还是被往年进程切换的入口点误导了较长时间。
最终还是实现了用户进程的正常启动和切换，不过此时进程的退出也有部分的问题。
- 5月17日
在查看网络上的virtio驱动后终于理解了virtio驱动的实现。used分区由qemu负责处理。于是在原来的轮询机制上实现了镜像读写，并且设计了接口。
- 5月19日
学习了fat32相关知识，去实现了fat32的文件系统功能，难点主要在于网络资料广而不统一，尤其是fat32标准也有不少版本，在使用linux工具生成的镜像和网络标准以及windows生成镜像的标准不统一。在实现fat32后时间已经十分紧张了于是粗简的实现了VFSM,功能十分有限。
- 5月20日
解析elf的难点还是在于协议的学习，不过往年的代码帮助了我们很多，在阅读代码之后很轻松的实现了从elf读取到用户进程的实现
- 5月22日
开始面向syscall不断补全系统构成，此时的系统有点积重难返，很多部件的小bug导致系统几乎无法运行，在紧急开会后。决定暂停新功能的编写，而将目前已有的所有bug进行修复。
解决了物理内存分配存在的小内存空间用尽导致的报错，fat32写入存在的问题，进程wait后发生的pid切换错误，在遇到不可执行文件造成的中断关闭死机问题。
- 5月27日
按部就班的实现syscall中的调用，vfsm设定太简单导致stdin和stdout无法解决，于是在write系统调用中使用trick解决。同时原本未考虑清楚的系统立即调度在实现yield系统调用时意识到可以使用异常进行触发，于是复用yield实现立即调度。
<p align="right">By:郭伟鑫</p>