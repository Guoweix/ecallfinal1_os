## 异常和中断
### 中断入口和出口
中断的入口和出口均由TrapEntry.S汇编负责，此汇编中有两个函数，分别负责中断的初步处理和中断的退出。
我们设定了一个TrapFrame用于保护现场,定义如下
```cpp
struct RegisterContext // 通用寄存器的上下文
{
    union // 使用联合体，这样既可以按名字访问寄存器，也可以按编号访问寄存器
    {
        RegisterData x[32];
        struct // 按照Risc-V64规范定义的32个寄存器
        {
            RegisterData zero,
                ra, sp, gp, tp,
                t0, t1, t2,
                s0, s1,
                a0, a1, a2, a3, a4, a5, a6, a7,
                s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,
                t3, t4, t5, t6;
        };
    };

    inline RegisterData& operator[](int index)
    {
        return x[index];
    }
};

struct TrapFrame // 一次中断/异常所需要保存的上下文/帧
{
    RegisterContext reg;
    RegisterData status, // 原先的CPU状态
        epc, // 原先的PC寄存器的值，表示程序执行的位置
        tval, // 地址例外中出错的地址、发生非法指令例外的指令本身、其他异常为0
        cause; // 中断/异常原因
};


```
汇编中的SAVE_ALL负责将当前的TrapFrame存到栈中，并且将栈指针传递给Trap.cpp的Trap函数
而RESTORE_ALL则负责从sp中将TrapFrame恢复成为运行的进程。而这是我们调度进程的核心，传入一个TrapFrame传出另一个TrapFrame，这点将在进程处详细讲解。
而TrapEntry.S的另一个特点就是会判断当前中断是在谁处发生的，如果在用户态中断，则将TrapFrame存储到用户对应的内核的栈，防止爆了用户的栈。
### 中断处理核心
中断服务函数的核心则是在Trap.cpp中的Trap函数，这个函数在每次进入的时候记录一个是否要调度的变量（needSchedule），对传入的TrapFrame中的a7，判断当前应该响应什么服务，最后返回的时候查看needSchedule变量去判断是否要进行调度。
这个函数最核心的思想是将所有中断和异常均使用相同的入口去处理，而使用switch统一管理，极大的简化了中断处理的流程，为后期处理syscall建立的基础

<p align="right">By:郭伟鑫</p>

`syscall` 调用是操作系统中用户程序请求内核服务的机制。用户程序通过 `syscall` 触发特权模式的切换，使得系统能够安全地处理底层任务如文件操作、内存管理和进程控制。此过程涉及中断机制以及用户态和内核态之间的转换。
首先，用户程序通过特定的指令发起 `syscall` 调用。这条指令会生成一个软件中断或系统调用中断，使得处理器从用户态切换到内核态。用户态是指程序运行在普通的权限级别下，仅能访问受限的资源，而内核态则是操作系统运行的特权模式，具有更高的权限，能够直接访问硬件资源和系统内部数据。
当 `syscall` 指令被执行时，处理器会保存当前用户程序的状态（如程序计数器和寄存器内容），并加载内核的中断处理程序。此时，控制权转移到操作系统内核，中断服务例程会检查 `syscall` 的参数并执行相应的服务。例如，内核会根据 `syscall` 提供的系统调用号调用相应的处理函数，如 `read`、`write` 或 `open`。
在内核态，操作系统执行相应的系统调用逻辑，并可能访问硬件或系统资源。处理完请求后，内核会准备返回结果，并恢复用户程序的状态。然后，处理器切换回用户态，恢复用户程序的执行。此切换通过特定的指令完成RESTORE ALL，恢复之前保存的寄存器和程序计数器，使得用户程序能够继续执行，就像没有发生过 `syscall` 调用一样。
总之，`syscall` 调用通过中断机制在用户态和内核态之间进行切换，允许用户程序安全地请求操作系统服务。这个过程确保了系统的稳定性和安全性，同时使得操作系统能够高效地管理资源和处理各种系统请求。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/44788784/1723980885312-1a1a522f-0320-4cdb-a7ea-102b207d0829.png#averageHue=%23f6f4f1&clientId=u67bb97ff-5f93-4&from=paste&height=503&id=u49a194c5&originHeight=754&originWidth=1408&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=73866&status=done&style=none&taskId=u284c7b04-2091-48e7-a74b-7453d5997c5&title=&width=938.6666666666666)
#### Syscall_execve
`Syscall_execve` 函数模拟了系统调用 `execve` 的操作，用于加载并执行指定路径的程序。首先，函数通过 `VirtualMemorySpace::EnableAccessUser()` 启用对用户内存的访问，并获取当前进程对象。接着，利用虚拟文件系统打开待执行的 ELF 文件，并初始化一个文件对象以进行读取操作。函数计算程序参数的数量，并将 `argv` 中的参数复制到新的内存区域中。随后，`CreateProcessFromELF` 被调用以从 ELF 文件中创建新的进程，并设置其文件描述符。
在新进程创建后，函数进入一个等待循环，检查子进程的状态，直到其执行完成。当前进程在子进程结束前会被阻塞，待子进程完成后，函数会回收其资源并获取退出码。最后，当前进程调用 `cur_proc->exit(exit_value)` 退出，并释放所有临时分配的内存，如文件对象。整个流程确保了新程序能够被正确加载和执行，同时保证了资源的正确管理和进程的正确退出。
#### Syscall_clone
`Syscall_clone` 函数实现了创建新进程或线程的系统调用，其执行流程根据 `stack` 参数的不同而有所变化。首先，函数会禁用中断以确保原子操作，通过 `IntrSave` 保存当前中断状态。接着，获取当前进程 `cur_proc` 并分配新的进程对象 `create_proc`。如果进程分配失败，函数会记录错误并返回 -1。若 `stack` 为 `nullptr`，表明这是一个类似 `fork` 的调用，函数会创建一个新的虚拟内存空间 `vms`，并复制当前进程的虚拟内存空间到新进程中。接下来，将当前进程的上下文（`TrapFrame`）复制到新进程的栈中，并更新上下文的程序计数器 `epc` 以及返回值 `a0` 为 0，标志新进程的创建成功。
如果 `stack` 不为 `nullptr`，函数执行类似于线程创建的操作，即执行 `clone`。新进程共享当前进程的虚拟内存空间，并将 `stack` 指定为新进程的栈指针。然后，将当前进程的上下文复制到新进程的栈中，并将新进程的栈指针 `sp` 设置为 `stack`。函数还会检查 `flags` 是否包含 `SIGCHLD` 标志，如果有，则设置新进程的名称并将其标记为当前进程的子进程。最后，将新进程的状态设置为准备就绪 (`S_Ready`)，恢复中断状态，并返回新进程的进程 ID。
####  Syscall_mkdirat  
首先，函数分配两个字符数组 `rela_wd` 和 `dir_path`。接着，获取当前进程对象 `cur_proc` 和当前工作目录 `cwd`。根据 `dirfd` 参数判断目录路径的基准点。如果 `dirfd` 为 `AT_FDCWD`，则使用当前工作目录作为基础路径，并将其复制到 `rela_wd`。如果 `dirfd` 不是 `AT_FDCWD`，函数通过文件描述符 `dirfd` 获取对应的文件对象 `fo`，并从中提取路径信息到 `rela_wd`。
随后，函数调用 `unified_path` 将相对路径与传入的路径合并，形成完整的目录路径 `dir_path`。接着，调用虚拟文件系统 (`vfsm`) 的 `create_dir` 函数在 `dir_path` 位置创建新目录。如果创建成功，函数返回 0；否则，返回 -1。在函数结束前，释放分配的内存。
####  Syscall_wait4  
`Syscall_wait4` 函数实现了一个系统调用，用于等待子进程的状态变化，通常是等待子进程结束。这个函数接收三个参数：`pid`（待等待的进程 ID）、`status`（存储子进程退出状态的指针），以及 `options`（等待选项）。如果 `pid` 为 -1，表示等待所有子进程。如果 `status` 非空，函数会将子进程的退出状态存储到 `status` 指向的位置。
函数的执行过程如下：首先，获取当前进程 `cur_proc` 并检查是否有子进程。如果没有子进程，输出警告并返回 -1。然后，进入一个循环，遍历所有子进程查找状态为终止 (`S_Terminated`) 的进程。若找到符合条件的子进程（即其 ID 为 `pid` 或 `pid` 为 -1），函数会将该子进程的 ID 存储在 `ret` 中。如果 `status` 不为空，函数会启用用户内存访问，将子进程的退出代码左移 8 位并存储到 `status` 指向的位置。然后，销毁并回收该子进程，返回子进程的 ID。
如果在遍历过程中没有找到符合条件的子进程且 `options` 参数中包含 `WNOHANG`，则立即返回 -1，表示没有子进程退出。如果 `WNOHANG` 未设置，则当前进程会阻塞，调用其信号量等待子进程的状态变化。一旦子进程结束并发出信号量，当前进程将被唤醒并重新调度。这个等待机制保证了父进程能在子进程结束后及时回收资源。
####  Syscall_times  
`Syscall_times` 函数用于获取当前进程的运行时间，包括用户态和核心态时间。它接受一个 `tms` 结构体指针，用于存储进程时间数据。函数首先获取当前进程 `cur_proc` 的运行时间和系统时间。`runTime` 表示总的运行时间，`sysTime` 表示系统时间（即陷入核心态的时间）。用户时间 `user_time` 是 `runTime` 减去 `sysTime`。
如果 `tms` 不为空，函数会计算用户态时间和系统态时间，按微秒为单位（`time_unit` 为 10）填充 `tms` 结构体。它还会遍历所有子进程，将它们的用户态和系统态时间累计到 `tms` 中。所有计算完成后，返回自系统启动以来的滴答数（即当前时间）。如果计算中的时间值为负，则视为出错并返回 -1。
####  Syscall_getdents64  
`Syscall_getdents64` 函数用于从目录中读取目录项，并将其信息填充到用户提供的缓冲区 `_buf` 中。该系统调用处理的目录项结构体 `Dirent` 包含了文件的索引节点号 (`d_ino`)、到下一个目录项的偏移 (`d_off`)、当前目录项的长度 (`d_reclen`)、文件类型 (`d_type`)、以及文件名 (`d_name`)。
函数首先获取当前进程 `proc` 和文件描述符 `fd` 对应的文件对象 `dir`。通过 `fom.get_from_fd` 查找该文件对象，若文件对象无效，则返回 -1。接着，函数从虚拟文件系统 (`vfsm`) 中获取目录的根节点，并通过 `get_next_file` 方法遍历目录中的文件。`file` 指针用于存储当前目录项的信息。
接下来，函数启用用户内存访问，以便能将数据写入用户空间。初始化 `n_read` 为已读取的字节数，并设置 `i` 为当前位置。如果当前文件指针为空，则返回 0 表示没有更多目录项可读。循环中，函数将目录项信息写入用户缓冲区 `_buf`，更新 `n_read`。如果缓冲区的剩余空间不足以容纳下一个目录项，则更新目录对象的当前位置 `pos_k` 并返回已读取的字节数。最终，函数更新目录的当前位置并返回已读取字节数。

